From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Thu, 12 Sep 2019 18:31:01 -0700
Subject: [PATCH] Add a metadata file named
 'fernflower_abstract_parameter_names.txt' to rename abstract parameters.
 Format: ClassName MethodName Descriptor Param1[ Param2...]


diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 561679a5f09b3b212dd6276ceab61539e93d006f..8df18a3a6ce27bd6b221dbd65ad2d87544137597 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -724,7 +724,8 @@ public class ClassWriter {
             String parameterName = methodWrapper.varproc.getVarName(new VarVersionPair(index, 0));
 
             if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) {
-              parameterName = methodWrapper.methodStruct.getVariableNamer().renameAbstractParameter(parameterName, index);
+              String newParameterName = methodWrapper.methodStruct.getVariableNamer().renameAbstractParameter(parameterName, index);
+              parameterName = !newParameterName.equals(parameterName) ? newParameterName : DecompilerContext.getStructContext().renameAbstractParameter(methodWrapper.methodStruct.getClassStruct().qualifiedName, mt.getName(), mt.getDescriptor(), index - (((flags & CodeConstants.ACC_STATIC) == 0) ? 1 : 0), parameterName);
             }
 
             buffer.append(parameterName == null ? "param" + index : parameterName); // null iff decompiled with errors
@@ -1029,4 +1030,4 @@ public class ClassWriter {
 
     buffer.append('>');
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/main/Fernflower.java b/src/org/jetbrains/java/decompiler/main/Fernflower.java
index 3003c67a9e45742cbfed1c8a2ad4a941cef11427..b0797ecc7340b98ce2b7badf1e8dd16435bde1cf 100644
--- a/src/org/jetbrains/java/decompiler/main/Fernflower.java
+++ b/src/org/jetbrains/java/decompiler/main/Fernflower.java
@@ -42,6 +42,7 @@ public class Fernflower implements IDecompiledData {
   public Fernflower(IBytecodeProvider provider, IResultSaver saver, Map<String, Object> options, IFernflowerLogger logger) {
     structContext = new StructContext(saver, this, new LazyLoader(provider));
     DecompilerContext.initContext(options, logger);
+    DecompilerContext.setStructContext(structContext);
     DecompilerContext.setCounterContainer(new CounterContainer());
 
     if (DecompilerContext.getOption(IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH)) {
diff --git a/src/org/jetbrains/java/decompiler/struct/ContextUnit.java b/src/org/jetbrains/java/decompiler/struct/ContextUnit.java
index 38c9487748ecc01f091e93dea28b250bf355549f..a7311f686300e0fd646a9b11d36a5ea3d84da2f8 100644
--- a/src/org/jetbrains/java/decompiler/struct/ContextUnit.java
+++ b/src/org/jetbrains/java/decompiler/struct/ContextUnit.java
@@ -21,12 +21,16 @@ import org.jetbrains.java.decompiler.main.extern.IResultSaver;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader.Link;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
+import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
+import java.io.File;
 import java.io.IOException;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
+import java.util.zip.ZipFile;
 
 public class ContextUnit {
 
@@ -68,6 +72,24 @@ public class ContextUnit {
   }
 
   public void addOtherEntry(String fullPath, String entry) {
+    if ("fernflower_abstract_parameter_names.txt".equals(entry)) {
+      byte[] data;
+      try {
+        if (type == TYPE_JAR || type == TYPE_ZIP) {
+          try (ZipFile archive = new ZipFile(fullPath)) {
+            data = InterpreterUtil.getBytes(archive, archive.getEntry(entry));
+          }
+        } else {
+          data = InterpreterUtil.getBytes(new File(fullPath));
+        }
+        DecompilerContext.getStructContext().loadAbstractMetadata(new String(data, StandardCharsets.UTF_8));
+      }
+      catch (IOException e) {
+        String message = "Cannot read fernflower_abstract_parameter_names.txt from " + fullPath;
+        DecompilerContext.getLogger().writeMessage(message, e);
+      }
+      return;
+    }
     otherEntries.add(new String[]{fullPath, entry});
   }
 
@@ -164,4 +186,4 @@ public class ContextUnit {
   public List<StructClass> getClasses() {
     return classes;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/struct/StructContext.java b/src/org/jetbrains/java/decompiler/struct/StructContext.java
index 40cf9cbc117a326a25c369f2625baf1cad21941b..970824161163de0cc08ff880f3f829731b8f47cf 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructContext.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructContext.java
@@ -18,14 +18,18 @@ package org.jetbrains.java.decompiler.struct;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.extern.IResultSaver;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger.Severity;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
 import java.io.File;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
@@ -38,6 +42,7 @@ public class StructContext {
   private final LazyLoader loader;
   private final Map<String, ContextUnit> units = new HashMap<>();
   private final Map<String, StructClass> classes = new HashMap<>();
+  private final Map<String, List<String>> abstractNames = new HashMap<>();
 
   public StructContext(IResultSaver saver, IDecompiledData decompiledData, LazyLoader loader) {
     this.saver = saver;
@@ -193,4 +198,25 @@ public class StructContext {
   public Map<String, StructClass> getClasses() {
     return classes;
   }
+
+
+  public void loadAbstractMetadata(String string) {
+    for (String line : string.split("\n")) {
+      String[] pts = line.split(" ");
+      if (pts.length < 4) //class method desc [args...]
+        continue;
+      GenericMethodDescriptor desc = GenericMain.parseMethodSignature(pts[2]);
+      List<String> params = new ArrayList<>();
+      for (int x = 0; x < pts.length - 3; x++) {
+        for (int y = 0; y < desc.params.get(x).stackSize; y++)
+            params.add(pts[x+3]);
+      }
+      this.abstractNames.put(pts[0] + ' '+ pts[1] + ' ' + pts[2], params);
+    }
+  }
+
+  public String renameAbstractParameter(String className, String methodName, String descriptor, int index, String _default) {
+    List<String> params = this.abstractNames.get(className + ' ' + methodName + ' ' + descriptor);
+    return params != null && index < params.size() ? params.get(index) : _default;
+  }
 }
