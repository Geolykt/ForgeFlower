From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Sun, 23 Feb 2020 21:28:31 -0800
Subject: [PATCH] Prioritize self and enclosing class when encountering
 inconsistent InnerClass attributes. The compiler encodes all REFERENCED inner
 classes into the class. The first found used to win, but now ThisClass >
 EnclosingClass > Others AccessTransformers only edit the targeted class as it
 can't find all references. Fixes AccessTransformers.


diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 8df18a3a6ce27bd6b221dbd65ad2d87544137597..9ec1f281b42cb787c65d76961b41a7221ad46b3f 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -41,6 +41,7 @@ import org.jetbrains.java.decompiler.struct.gen.generics.*;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
 import java.util.*;
+import java.util.stream.Collectors;
 
 public class ClassWriter {
   private final PoolInterceptor interceptor;
@@ -1007,6 +1008,10 @@ public class ClassWriter {
     }
   }
 
+  public static String getModifiers(int flags) {
+    return MODIFIERS.entrySet().stream().filter(e -> (e.getKey() & flags) != 0).map(Map.Entry::getValue).collect(Collectors.joining(" "));
+  }
+
   public static void appendTypeParameters(TextBuffer buffer, List<String> parameters, List<List<VarType>> bounds) {
     buffer.append('<');
 
diff --git a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
index 64ebc94524843ae842add1f45c1649c0ed0ec633..662741a495c747b004f5ca11336d48e9471c9efa 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassesProcessor.java
@@ -50,10 +50,20 @@ public class ClassesProcessor {
     private String simpleName;
     private int type;
     private int accessFlags;
+    private String source;
 
     private static boolean equal(Inner o1, Inner o2) {
       return o1.type == o2.type && o1.accessFlags == o2.accessFlags && InterpreterUtil.equalObjects(o1.simpleName, o2.simpleName);
     }
+
+    @Override
+    public String toString() {
+      return simpleName + " " + ClassWriter.getModifiers(accessFlags) + " " + getType() + " " + source;
+    }
+
+    private String getType() {
+      return type == ClassNode.CLASS_ANONYMOUS ? "ANONYMOUS" : type == ClassNode.CLASS_LAMBDA ? "LAMBDA" : type == ClassNode.CLASS_LOCAL ? "LOCAL" : type == ClassNode.CLASS_MEMBER ? "MEMBER" : type == ClassNode.CLASS_ROOT ? "ROOT" : "UNKNOWN(" + type +")";
+    }
   }
 
   public ClassesProcessor(StructContext context) {
@@ -92,6 +102,7 @@ public class ClassesProcessor {
               rec.simpleName = simpleName;
               rec.type = entry.outerNameIdx != 0 ? ClassNode.CLASS_MEMBER : entry.simpleNameIdx != 0 ? ClassNode.CLASS_LOCAL : ClassNode.CLASS_ANONYMOUS;
               rec.accessFlags = entry.accessFlags;
+              rec.source = cl.qualifiedName;
 
               // nested class type
               if (entry.innerName != null) {
@@ -138,6 +149,13 @@ public class ClassesProcessor {
                   else if (!Inner.equal(existingRec, rec)) {
                     String message = "Inconsistent inner class entries for " + innerName + "!";
                     DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
+                    DecompilerContext.getLogger().writeMessage("  Old: " + existingRec.toString(), IFernflowerLogger.Severity.WARN);
+                    DecompilerContext.getLogger().writeMessage("  New: " + rec.toString(), IFernflowerLogger.Severity.WARN);
+                    int oldPriority = existingRec.source.equals(innerName) ? 1 : existingRec.source.equals(enclClassName) ? 2 : 3;
+                    int newPriority = rec.source.equals(innerName) ? 1 : rec.source.equals(enclClassName) ? 2 : 3;
+                    if (newPriority < oldPriority) {
+                        mapInnerClasses.put(innerName, rec);
+                    }
                   }
 
                   // reference to the nested class
