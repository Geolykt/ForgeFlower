From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Wed, 12 Apr 2017 18:37:18 -0700
Subject: [PATCH] Reintroduce DotExporter for debugging purposes


diff --git a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
index ba77e1e6519719b3f06f27a70de72b81c1136404..7367df006ea8de2dd69603e5d87772457166dc47 100644
--- a/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
+++ b/src/org/jetbrains/java/decompiler/main/rels/NestedClassProcessor.java
@@ -40,6 +40,7 @@ import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.attr.StructEnclosingMethodAttribute;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.util.DotExporter;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
 import java.util.*;
@@ -410,6 +411,7 @@ public class NestedClassProcessor {
       // iterate enclosing class
       for (final MethodWrapper method : node.getWrapper().getMethods()) {
         if (method.root != null) { // neither abstract, nor native
+          DotExporter.toDotFile(method.getOrBuildGraph(), method.methodStruct, "computeLocalVars");
           method.getOrBuildGraph().iterateExprents(new DirectGraph.ExprentIterator() {
             @Override
             public int processExprent(Exprent exprent) {
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
index b6a2245636a34e824abc3f55940fa60d21d06512..df3c1b54539f0e52f96103c15cc767d5eef3c08c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAConstructorSparseEx.java
@@ -28,6 +28,7 @@ import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
+import org.jetbrains.java.decompiler.util.DotExporter;
 import org.jetbrains.java.decompiler.util.FastSparseSetFactory;
 import org.jetbrains.java.decompiler.util.FastSparseSetFactory.FastSparseSet;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
@@ -69,9 +70,7 @@ public class SSAConstructorSparseEx {
     FlattenStatementsHelper flatthelper = new FlattenStatementsHelper();
     DirectGraph dgraph = flatthelper.buildDirectGraph(root);
 
-    // try {
-    // DotExporter.toDotFile(dgraph, new File("c:\\Temp\\gr12_my.dot"));
-    // } catch(Exception ex) {ex.printStackTrace();}
+    DotExporter.toDotFile(dgraph, mt, "ssaSplitVariables");
 
     List<Integer> setInit = new ArrayList<>();
     for (int i = 0; i < 64; i++) {
@@ -84,20 +83,19 @@ public class SSAConstructorSparseEx {
 
     setCatchMaps(root, dgraph, flatthelper);
 
+    int itteration = 1;
     HashSet<String> updated = new HashSet<>();
     do {
       // System.out.println("~~~~~~~~~~~~~ \r\n"+root.toJava());
-      ssaStatements(dgraph, updated);
+      ssaStatements(dgraph, updated, mt, itteration++);
       // System.out.println("~~~~~~~~~~~~~ \r\n"+root.toJava());
     }
     while (!updated.isEmpty());
   }
 
-  private void ssaStatements(DirectGraph dgraph, HashSet<String> updated) {
+  private void ssaStatements(DirectGraph dgraph, HashSet<String> updated, StructMethod mt, int itteration) {
 
-    // try {
-    // DotExporter.toDotFile(dgraph, new File("c:\\Temp\\gr1_my.dot"));
-    // } catch(Exception ex) {ex.printStackTrace();}
+    DotExporter.toDotFile(dgraph, mt, "ssaStatements_" + itteration, outVarVersions);
 
     for (DirectNode node : dgraph.nodes) {
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
index 01d21d5f566ad21ac5a38fcff8a48c1595420903..6f3ab79e253745dae21ff2395229d2fd17e94791 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/sforms/SSAUConstructorSparseEx.java
@@ -25,6 +25,7 @@ import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionsGraph;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
+import org.jetbrains.java.decompiler.util.DotExporter;
 import org.jetbrains.java.decompiler.util.FastSparseSetFactory;
 import org.jetbrains.java.decompiler.util.FastSparseSetFactory.FastSparseSet;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
@@ -88,6 +89,8 @@ public class SSAUConstructorSparseEx {
     FlattenStatementsHelper flatthelper = new FlattenStatementsHelper();
     DirectGraph dgraph = flatthelper.buildDirectGraph(root);
 
+    DotExporter.toDotFile(dgraph, mt, "ssauSplitVariables");
+    
     List<Integer> setInit = new ArrayList<>();
     for (int i = 0; i < 64; i++) {
       setInit.add(i);
@@ -98,25 +101,24 @@ public class SSAUConstructorSparseEx {
 
     setCatchMaps(root, dgraph, flatthelper);
 
-    //		try {
-    //			DotExporter.toDotFile(dgraph, new File("c:\\Temp\\gr12_my.dot"));
-    //		} catch(Exception ex) {ex.printStackTrace();}
-
+    int itteration = 1;
     HashSet<String> updated = new HashSet<>();
     do {
       //			System.out.println("~~~~~~~~~~~~~ \r\n"+root.toJava());
-      ssaStatements(dgraph, updated, false);
+      ssaStatements(dgraph, updated, false, mt, itteration++);
       //			System.out.println("~~~~~~~~~~~~~ \r\n"+root.toJava());
     }
     while (!updated.isEmpty());
 
 
-    ssaStatements(dgraph, updated, true);
+    ssaStatements(dgraph, updated, true, mt, itteration++);
 
     ssuversions.initDominators();
   }
 
-  private void ssaStatements(DirectGraph dgraph, HashSet<String> updated, boolean calcLiveVars) {
+  private void ssaStatements(DirectGraph dgraph, HashSet<String> updated, boolean calcLiveVars, StructMethod mt, int itteration) {
+
+    DotExporter.toDotFile(dgraph, mt, "ssauStatements_" + itteration);
 
     for (DirectNode node : dgraph.nodes) {
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
index cce407c66a2010c92450dd62473183964b90a3cf..4c18dd75be0571a70a9594ec454a4e3ee1ba4765 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarVersionsProcessor.java
@@ -28,6 +28,7 @@ import org.jetbrains.java.decompiler.modules.decompiler.stats.RootStatement;
 import org.jetbrains.java.decompiler.struct.StructMethod;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.util.DotExporter;
 import org.jetbrains.java.decompiler.util.FastSparseSetFactory.FastSparseSet;
 
 import java.util.*;
@@ -50,6 +51,8 @@ public class VarVersionsProcessor {
     FlattenStatementsHelper flattenHelper = new FlattenStatementsHelper();
     DirectGraph graph = flattenHelper.buildDirectGraph(root);
 
+    DotExporter.toDotFile(graph, method, "setVarVersions");
+
     mergePhiVersions(ssa, graph);
 
     typeProcessor.calculateVarTypes(root, graph);
diff --git a/src/org/jetbrains/java/decompiler/util/DotExporter.java b/src/org/jetbrains/java/decompiler/util/DotExporter.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3c6f92fbe0e8304f4f3e8d110dbee77eb04fe56
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/util/DotExporter.java
@@ -0,0 +1,238 @@
+package org.jetbrains.java.decompiler.util;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+
+import org.jetbrains.java.decompiler.code.cfg.BasicBlock;
+import org.jetbrains.java.decompiler.code.cfg.ControlFlowGraph;
+import org.jetbrains.java.decompiler.modules.decompiler.StatEdge;
+import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectGraph;
+import org.jetbrains.java.decompiler.modules.decompiler.sforms.DirectNode;
+import org.jetbrains.java.decompiler.modules.decompiler.stats.Statement;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionEdge;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionNode;
+import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionsGraph;
+import org.jetbrains.java.decompiler.struct.StructMethod;
+import org.jetbrains.java.decompiler.util.FastSparseSetFactory.FastSparseSet;
+
+public class DotExporter {
+  private static final String DOTS_FOLDER = System.getProperty("DOT_EXPORT_DIR", null);
+  private static final boolean DUMP_DOTS = DOTS_FOLDER != null;
+  // http://graphs.grevian.org/graph is a nice visualizer for the outputed dots.
+
+  private static String toDotFormat(Statement stat) {
+
+    StringBuffer buffer = new StringBuffer();
+
+    buffer.append("digraph G {\r\n");
+
+    for(Statement st : stat.getStats()) {
+
+      String sourceid = st.id + (st.getSuccessorEdges(StatEdge.TYPE_EXCEPTION).isEmpty()?"":"000000");
+
+      buffer.append(sourceid+" [shape=box,label=\""+sourceid+"\"];\r\n");
+
+      for(StatEdge edge : st.getSuccessorEdges(Statement.STATEDGE_DIRECT_ALL)) {
+        String destid = edge.getDestination().id + (edge.getDestination().getSuccessorEdges(StatEdge.TYPE_EXCEPTION).isEmpty()?"":"000000");
+
+        buffer.append(sourceid+"->"+destid+";\r\n");
+
+        if(!stat.getStats().contains(edge.getDestination())) {
+          buffer.append(destid+" [label=\""+destid+"\"];\r\n");
+        }
+      }
+
+      for(StatEdge edge : st.getSuccessorEdges(StatEdge.TYPE_EXCEPTION)) {
+        String destid = edge.getDestination().id + (edge.getDestination().getSuccessorEdges(StatEdge.TYPE_EXCEPTION).isEmpty()?"":"000000");
+
+        buffer.append(sourceid+" -> "+destid+" [style=dotted];\r\n");
+
+        if(!stat.getStats().contains(edge.getDestination())) {
+          buffer.append(destid+" [label=\""+destid+"\"];\r\n");
+        }
+      }
+    }
+
+    buffer.append("}");
+
+    return buffer.toString();
+  }
+
+
+  private static String toDotFormat(ControlFlowGraph graph, boolean showMultipleEdges) {
+
+    StringBuffer buffer = new StringBuffer();
+
+    buffer.append("digraph G {\r\n");
+
+    List<BasicBlock> blocks = graph.getBlocks();
+    for(int i=0;i<blocks.size();i++) {
+      BasicBlock block = (BasicBlock)blocks.get(i);
+
+      buffer.append(block.id+" [shape=box,label=\""+block.id+"\"];\r\n");
+
+
+      List<BasicBlock> suc = block.getSuccs();
+      if(!showMultipleEdges) {
+        HashSet<BasicBlock> set = new HashSet<BasicBlock>();
+        set.addAll(suc);
+        suc = Collections.list(Collections.enumeration(set));
+      }
+      for(int j=0;j<suc.size();j++) {
+        buffer.append(block.id+"->"+((BasicBlock)suc.get(j)).id+";\r\n");
+      }
+
+
+      suc = block.getSuccExceptions();
+      if(!showMultipleEdges) {
+        HashSet<BasicBlock> set = new HashSet<BasicBlock>();
+        set.addAll(suc);
+        suc = Collections.list(Collections.enumeration(set));
+      }
+      for(int j=0;j<suc.size();j++) {
+        buffer.append(block.id+" -> "+((BasicBlock)suc.get(j)).id+" [style=dotted];\r\n");
+      }
+    }
+
+    buffer.append("}");
+
+    return buffer.toString();
+  }
+
+  private static String toDotFormat(VarVersionsGraph graph) {
+
+    StringBuffer buffer = new StringBuffer();
+
+    buffer.append("digraph G {\r\n");
+
+    List<VarVersionNode> blocks = graph.nodes;
+    for(int i=0;i<blocks.size();i++) {
+      VarVersionNode block = blocks.get(i);
+
+      buffer.append((block.var*1000+block.version)+" [shape=box,label=\""+block.var+"_"+block.version+"\"];\r\n");
+
+      for(VarVersionEdge edge: block.succs) {
+        VarVersionNode dest = edge.dest;
+        buffer.append((block.var*1000+block.version)+"->"+(dest.var*1000+dest.version)+(edge.type==VarVersionEdge.EDGE_PHANTOM?" [style=dotted]":"")+";\r\n");
+      }
+    }
+
+    buffer.append("}");
+
+    return buffer.toString();
+  }
+
+  private static String toDotFormat(DirectGraph graph, Map<String, SFormsFastMapDirect> vars) {
+
+    StringBuffer buffer = new StringBuffer();
+
+    buffer.append("digraph G {\r\n");
+
+    List<DirectNode> blocks = graph.nodes;
+    for(int i=0;i<blocks.size();i++) {
+      DirectNode block = blocks.get(i);
+
+      StringBuilder label = new StringBuilder(block.id);
+      if (vars != null && vars.containsKey(block.id)) {
+        SFormsFastMapDirect map = vars.get(block.id);
+
+        List<Entry<Integer, FastSparseSet<Integer>>> lst = map.entryList();
+        if (lst != null) {
+          for (Entry<Integer, FastSparseSet<Integer>> entry : lst) {
+             label.append("\\n").append(entry.getKey());
+            Set<Integer> set = entry.getValue().toPlainSet();
+            label.append("=").append(set.toString());
+          }
+        }
+      }
+
+      buffer.append(directBlockIdToDot(block.id)+" [shape=box,label=\""+label+"\"];\r\n");
+
+      for(DirectNode dest: block.succs) {
+        buffer.append(directBlockIdToDot(block.id)+"->"+directBlockIdToDot(dest.id)+";\r\n");
+      }
+    }
+
+    buffer.append("}");
+
+    return buffer.toString();
+  }
+
+  private static String directBlockIdToDot(String id) {
+    id = id.replaceAll("_try", "999");
+    id = id.replaceAll("_tail", "888");
+
+    id = id.replaceAll("_init", "111");
+    id = id.replaceAll("_cond", "222");
+    id = id.replaceAll("_inc", "333");
+    return id;
+  }
+
+  private static File getFile(StructMethod mt, String suffix) {
+    File root = new File(DOTS_FOLDER + mt.getClassStruct().qualifiedName);
+    if (!root.isDirectory())
+      root.mkdirs();
+    return new File(root,
+      mt.getName().replace('<', '.').replace('>', '_') +
+      mt.getDescriptor().replace('/', '.') +
+      '_' + suffix + ".dot");
+  }
+
+  public static void toDotFile(DirectGraph dgraph, StructMethod mt, String suffix) {
+    toDotFile(dgraph, mt, suffix, null);
+  }
+  public static void toDotFile(DirectGraph dgraph, StructMethod mt, String suffix, Map<String, SFormsFastMapDirect> vars) {
+    if (!DUMP_DOTS)
+      return;
+    try{
+      BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(getFile(mt, suffix)));
+      out.write(toDotFormat(dgraph, vars).getBytes());
+      out.close();
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+
+  public static void toDotFile(Statement stat, StructMethod mt, String suffix) {
+    if (!DUMP_DOTS)
+      return;
+    try{
+      BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(getFile(mt, suffix)));
+      out.write(toDotFormat(stat).getBytes());
+      out.close();
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+
+  public static void toDotFile(VarVersionsGraph graph, StructMethod mt, String suffix) {
+    if (!DUMP_DOTS)
+      return;
+    try{
+      BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(getFile(mt, suffix)));
+      out.write(toDotFormat(graph).getBytes());
+      out.close();
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+
+  public static void toDotFile(ControlFlowGraph graph, StructMethod mt, String suffix, boolean showMultipleEdges) {
+    if (!DUMP_DOTS)
+      return;
+    try{
+      BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(getFile(mt, suffix)));
+      out.write(toDotFormat(graph, showMultipleEdges).getBytes());
+      out.close();
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+  }
+}
\ No newline at end of file
